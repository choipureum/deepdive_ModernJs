# part 2-1

# Prototype 타입
## 기본
### 요약
```
js는 프로토타입 기반 언어
-> 이를 기반으로 확장성과 재사용성을 높임.
사전적의미: 원형을 가지고 새로운 객체를 생성해가는 프로그래밍 방식
-> 생성된 객체는 자기자신의 프로토타입을 가짐 
```

### Prototype vs Class
```
클래스 지원 이전,
객체의 프로토타입을 이용해서 객체의 확장성, 재사용, 상속을 구현해 나갔다.
프로토타입의 객체는 new연산자에 의해 생성된 객체 -> 공유 프로퍼티, 메서드 등을 제공하기 위해 사용됨
```

### 예시
```js
const fruit = {
    name:'apple'
};
console.log(fruit.name); // apple

// 속성추가
fruit.expiration = '20220908';

// 속성이 있는지 체크
console.log(fruit.hasOwnProperty('expiration')); // true
console.log(fruit.hasOwnProperty('country')); // false

// hasOwnProperty() 와같이 모든 객체는 __proto__를 자동으로 가지고있음

// proto 메소드를 fruit에 정의 한다면?
const fruit = {
    name:'apple',
    expiration:'20221231',
    hasOwnProperty:function(){
        console.log('hi');
    },
}
fruit.hasOwnProperty(); //hi -> __proto__보다 우선됨
```

## 함수의 내부와 객체간의 관계

### 함수가 만들어지고 수행과정

1. 함수 자신과 자신과같은 이름의 Animal 프로토타입 객체 생성
2. 함수 멤버로 Animal 프로토타입 속성 생성 -> 다른 곳에서 생성된 같은 함수 이름의 Animal 프로토타입 객체를 참조
3. 만약 Animal 내부 run 함수를 만들 경우 상속받는 모든 동물 객체는 run을 정의 해야함 -> 메모리 낭비
4. 즉 Animal Prototype객체 = 생성자 함수와 new 연산자를 통해서 만든 모든 객체의 원형

```javascript
function Animal(){} // __proto__ (Animal proto 객체)
let tiger = new Animal(); // constructor = Amimal(), __proto__(Animal proto객체) 
let lion = new Animal(); // constructor = Amimal(), __proto__(Animal proto객체)
//-> __proto__ 자동 생성
// Animal 프로토 타입 객체 -> tiger, lion 과 같은 객체의 원형이 됨
// 모두 Anima; 프로토 객체에 접근 가능
// Animal Protoa에 차가시 tiger, lion 공유 가능

Animal.prototype.run = funtion(){
    return 'run';
}
console.log(tiger.run()) // run
console.log(lion.run()) // run
console.log(Animal.prototype.run());// run
// 속성 추가
tiger.leg = 4;
console.log(tiger.leg); // 4
```
