# part 2-1

# Prototype 타입
## 기본
### 요약
```
js는 프로토타입 기반 언어
-> 이를 기반으로 확장성과 재사용성을 높임.
사전적의미: 원형을 가지고 새로운 객체를 생성해가는 프로그래밍 방식
-> 생성된 객체는 자기자신의 프로토타입을 가짐 
```

### Prototype vs Class
```
클래스 지원 이전,
객체의 프로토타입을 이용해서 객체의 확장성, 재사용, 상속을 구현해 나갔다.
프로토타입의 객체는 new연산자에 의해 생성된 객체 -> 공유 프로퍼티, 메서드 등을 제공하기 위해 사용됨
```

### 예시
```js
const fruit = {
    name:'apple'
};
console.log(fruit.name); // apple

// 속성추가
fruit.expiration = '20220908';

// 속성이 있는지 체크
console.log(fruit.hasOwnProperty('expiration')); // true
console.log(fruit.hasOwnProperty('country')); // false

// hasOwnProperty() 와같이 모든 객체는 __proto__를 자동으로 가지고있음

// proto 메소드를 fruit에 정의 한다면?
const fruit = {
    name:'apple',
    expiration:'20221231',
    hasOwnProperty:function(){
        console.log('hi');
    },
}
fruit.hasOwnProperty(); //hi -> __proto__보다 우선됨
```

## 함수의 내부와 객체간의 관계

### 함수가 만들어지고 수행과정

1. 함수 자신과 자신과같은 이름의 Animal 프로토타입 객체 생성
2. 함수 멤버로 Animal 프로토타입 속성 생성 -> 다른 곳에서 생성된 같은 함수 이름의 Animal 프로토타입 객체를 참조
3. 만약 Animal 내부 run 함수를 만들 경우 상속받는 모든 동물 객체는 run을 정의 해야함 -> 메모리 낭비
4. 즉 Animal Prototype객체 = 생성자 함수와 new 연산자를 통해서 만든 모든 객체의 원형

```javascript
function Animal(){} // __proto__ (Animal proto 객체)
let tiger = new Animal(); // constructor = Amimal(), __proto__(Animal proto객체) 
let lion = new Animal(); // constructor = Amimal(), __proto__(Animal proto객체)
//-> __proto__ 자동 생성
// Animal 프로토 타입 객체 -> tiger, lion 과 같은 객체의 원형이 됨
// 모두 Anima; 프로토 객체에 접근 가능
// Animal Protoa에 차가시 tiger, lion 공유 가능

Animal.prototype.run = funtion(){
    return 'run';
}
console.log(tiger.run()) // run
console.log(lion.run()) // run
console.log(Animal.prototype.run());// run
// 속성 추가
tiger.leg = 4;
console.log(tiger.leg); // 4
```

## 객체 생성시 생성자 안에서 메서드를 정의하면 안되는 이유
* 메모리 부하, 낭비
```js
function add(a,b){
    this.a = a;
    this.b = b;
    this.plus = function(){
        return this.a+this.b;
    }
}

let adfunc = new add(100,200);
console.log(adfunc.plus()); // 300
console.log(adfunc);
// 프로토타입 객체를 바라보지 않기 때문에 
// new 로 객체를 생성할때마다 plus를 계속 만듬 -> 메모리 부하

// 2. 프로토타입 변환 
function add(a,b){
    this.a = a;
    this.b = b;
}
add.prototype.plus = function(){
    return this.a + this.b;
}
let adfunc = new add(100,200);
console.log(adfunc.plus());
```

## 상속
1. js 는 객체지향언어인가 -> oop언어 맞음/ but 프로토타입 상속에 기반을 둔 언어 -> 이제 class 지원
2. 필요성 = 어떤 체이닝(연결)을 통한 재사용
3. 이미 부모쪽에서 정의된 속성과 메서드를 상속해 재사용 & 확장
4. 중복작성을 방지하고 확장성 O

### 프로토타입 체인
```js
__proto__ : 상속을 해준 원형(부모)를 참조(가르킴)
-> 부모객체의 멤버(속성, 메서드)를 사용할 수 있다.

let obj1 = {
    name : '최푸름',
    age : '29',
    sayHi: function(){
        console.log(this.name);
    },
};

let obj2 = {
    name : '최오름',
}

//obj2 의 __proto__가 참조하는 것은?
console.log(obj2); //__proto__ =  최상위 object 를 가르킴 - 따로 생성한게 아님

// __proto__ 속성 참조를 바꿀수 있는가? = Yes
obj2.__proto__ = obj1; // proto 변경
console.log(obj2.age); // 29
console.log(obj2.name); // 최오름
console.log(obj2.sayHi()); // 최오름

// ---------------------------
let obj3 = {
// __proto__ = Object.prototype
// Object.protype.__proto__ = null;
}

obj3.__proto__ = obj2; // obj2의 프로토, obj1의 프로토, 최상위 프로토 모두 가짐 -> 프로토타입 체인
console.log(obj3.hasOwnProperty('jgjh0')); // false

console.log(obj3.name) // 최오름
console.log(obj3.age) // 29
obj3.sayHi(); // 최오름
```
---
**NOTE**

1. js는 지신에게 없는 특성(속성, 메서드)를 `__proto__`가 참조하는 부모에서 가져온다.
2. 맨 하위 객체 부터 탐색(자식부터 -> 부모로)
3. `__proto__` 속성이 참조하는 프로토타입이 상속을 해준 부모이다.
4. 이와같이 js는 프로토타입체인을 통해 객체의 특성(속성, 메서드)을 다른 객체로 전파.
5. 즉 js는 프로토타입 상속으로 구현하는 OOP 언어. = 프로토타입 기반의 OOP 언어
---

<br>

## 객체의 프로토타입 출력
1. `__proto__` : 일부 브라우저에서 미지원 할 수 있음
2. `Object.getPrototypeOf()` 


```js
function ex(){}
let obj = new ex();

console.log(obj.__proto__) // ex() 
console.log(Object.getPrototyprOf(obj)); // ex()

console.log(obj.__proto === Object.getPrototypeOf(obj)) // true
```
